name: Auto Translate OpenClaw Docs

on:
  schedule:
    # 每小时检查一次更新
    - cron: '0 * * * *'
  workflow_dispatch: # 允许手动触发

jobs:
  translate-docs:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 2  # 获取最近两次提交以进行比较
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Install dependencies
      run: |
        npm install js-yaml
        
    - name: Fetch latest OpenClaw docs
      run: |
        # 克隆最新的 OpenClaw 仓库
        if [ -d "openclaw-temp" ]; then
          rm -rf openclaw-temp
        fi
        git clone --depth 1 https://github.com/openclaw/openclaw.git openclaw-temp
        
    - name: Compare and identify changed files
      run: |
        # 检查上次运行后是否有更新
        if [ -d "docs_original" ]; then
          # 创建临时目录
          mkdir -p temp_comparison
          
          # 复制现有原始文档和新文档到临时目录进行比较
          cp -r docs_original/* temp_comparison/original/ 2>/dev/null || true
          cp -r openclaw-temp/docs/* temp_comparison/new/ 2>/dev/null || true
          
          # 检查文件差异
          CHANGES=$(diff -rq temp_comparison/original/ temp_comparison/new/ 2>&1 | grep -E "(differ|Only in temp_comparison/new)" | grep "\.md" | head -n 10 || true)
          
          if [ -n "$CHANGES" ]; then
            echo "Changes detected"
            # 提取变更的文件名
            echo "$CHANGES" | grep -oE "temp_comparison/new/[a-zA-Z0-9/_\-\.]+\.md" | sed 's/temp_comparison\/new\///' > changed_files.txt
            echo "UPDATES_AVAILABLE=true" >> $GITHUB_ENV
          else
            echo "No changes detected"
            echo "UPDATES_AVAILABLE=false" >> $GITHUB_ENV
          fi
        else
          echo "First run - initializing with initial set of files"
          # 第一次运行，选取前几个文件进行处理以避免超时
          find openclaw-temp/docs -name "*.md" | head -n 10 | while read -r file; do
            rel_path="${file#openclaw-temp/docs/}"
            echo "$rel_path" >> changed_files.txt
          done
          echo "UPDATES_AVAILABLE=true" >> $GITHUB_ENV
        fi
        
        # 统计变更文件数量
        if [ -f changed_files.txt ] && [ -s changed_files.txt ]; then
          COUNT=$(wc -l < changed_files.txt)
          echo "CHANGES_COUNT=$COUNT" >> $GITHUB_ENV
          echo "Processing $COUNT files to avoid timeout..."
        else
          echo "UPDATES_AVAILABLE=false" >> $GITHUB_ENV
        fi
    
    - name: Update original docs
      run: |
        # 更新原始文档副本
        rm -rf docs_original
        cp -r openclaw-temp/docs docs_original
        
    - name: Process changed files with translation
      if: env.UPDATES_AVAILABLE == 'true'
      run: |
        # 创建输出目录
        mkdir -p docs_zh
        
        # 读取变更的文件列表
        if [ -f changed_files.txt ]; then
          while IFS= read -r file; do
            if [ -n "$file" ] && [ -f "openclaw-temp/docs/$file" ]; then
              echo "Processing: $file"
              
              # 创建目标目录结构
              mkdir -p "docs_zh/$(dirname "$file")"
              
              # 运行翻译脚本处理单个文件
        FILE_PATH="$file"
        export FILE_PATH
        node -c "
          const fs = require('fs');
          const path = require('path');
          const yaml = require('js-yaml');
          
          // 加载术语表
          const terminology = require('./terminology.json');
          
          // 从环境变量获取文件路径
          const filePath = process.env.FILE_PATH;
          
          // 读取原始文档内容
          const content = fs.readFileSync('openclaw-temp/docs/' + filePath, 'utf8');
          
          /**
           * 从Markdown内容中提取frontmatter
           */
          function extractFrontMatter(content) {
            const frontMatterRegex = /^---\\n([\\s\\S]*?)\\n---\\n/;
            const match = content.match(frontMatterRegex);
            
            if (match) {
              const frontMatter = yaml.load(match[1]);
              const body = content.slice(match[0].length);
              return { frontMatter, body };
            }
            
            return { frontMatter: null, body: content };
          }
          
          /**
           * 翻译frontmatter中的特定字段
           */
          function translateFrontMatter(frontMatter) {
            if (!frontMatter) return null;
            
            const translatedFM = { ...frontMatter };
            
            // 翻译summary字段
            if (translatedFM.summary) {
              translatedFM.summary = translateText(translatedFM.summary);
            }
            
            // 翻译read_when字段
            if (translatedFM.read_when && Array.isArray(translatedFM.read_when)) {
              translatedFM.read_when = translatedFM.read_when.map(item => translateText(item));
            }
            
            return translatedFM;
          }
          
          /**
           * 基于术语表翻译文本
           */
          function translateText(text) {
            if (!text || typeof text !== 'string') {
              return text;
            }
            
            // 使用术语表进行翻译
            let translated = text;
            for (const [english, chinese] of Object.entries(terminology)) {
              // 使用全局正则表达式替换，避免重复替换
              const regex = new RegExp(english.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
              translated = translated.replace(regex, chinese);
            }
            
            return translated;
          }
          
          /**
           * 重新构建带有frontmatter的文档
           */
          function rebuildDocument(frontMatter, body) {
            let result = '';
            
            if (frontMatter) {
              result += '---\\n';
              result += yaml.dump(frontMatter);
              result += '---\\n\\n';
            }
            
            result += body;
            return result;
          }
          
          // 执行翻译过程
          try {
            const { frontMatter, body } = extractFrontMatter(content);
            const translatedFrontMatter = translateFrontMatter(frontMatter);
            const translatedBody = translateText(body);
            
            const finalContent = rebuildDocument(translatedFrontMatter, translatedBody);
            
            // 确保输出目录存在
            const outputPath = path.dirname('docs_zh/' + filePath);
            if (!fs.existsSync(outputPath)) {
              fs.mkdirSync(outputPath, { recursive: true });
            }
            
            // 写入翻译后的文件
            fs.writeFileSync('docs_zh/' + filePath, finalContent, 'utf8');
            console.log('Successfully translated: ' + filePath);
          } catch (error) {
            console.error('Error translating ' + filePath + ':', error.message);
            // 即使出错也复制原文件，避免缺失
            fs.copyFileSync('openclaw-temp/docs/' + filePath, 'docs_zh/' + filePath);
          }
        "
            fi
          done < changed_files.txt
        fi
        
        # 复制翻译后的文档到网站目录
        if [ -d docs_zh ]; then
          mkdir -p docs
          rsync -av --ignore-existing docs_zh/ docs/
        fi
        
    - name: Setup Jekyll
      if: env.UPDATES_AVAILABLE == 'true'
      uses: actions/configure-pages@v4
      
    - name: Build with Jekyll
      if: env.UPDATES_AVAILABLE == 'true'
      uses: actions/jekyll-build-pages@v1
      with:
        source: ./
        destination: ./_site
        
    - name: Commit and push changes
      if: env.UPDATES_AVAILABLE == 'true'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add .
        git commit -m "Auto-translate: 更新 OpenClaw 中文文档 [skip ci]" || exit 0
        git push
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Upload site artifact
      if: env.UPDATES_AVAILABLE == 'true'
      uses: actions/upload-pages-artifact@v4
      with:
        path: "_site/"
        
    - name: Deploy to GitHub Pages
      if: env.UPDATES_AVAILABLE == 'true'
      uses: actions/deploy-pages@v4